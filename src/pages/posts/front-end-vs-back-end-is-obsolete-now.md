---
layout: ../../layouts/MarkdownPostLayout.astro
title: "Front-end vs. back-end is obsolete now"
pubDate: 2025-05-14
description: "Front-end and back-end roles have blurred. Let's explore how the distinction between these roles became obsolete and what it means to be a developer today."
image:
  url: "2025.webp"
  alt: "It's 2025, blurred lines between front-end and back-end"
tags: ["frontend", "backend", "full-stack", "javascript", "nodejs", "devops", "web-development", "ci-cd", "infrastructure", "microservices", "cloud"]
---
## In the beginning, there was just the web

When I first started web development (last century! lol), nobody used the terms "front-end" or "back-end" developers. We built web pages by writing HTML, styling them with CSS, and adding a bit of interactivity with JavaScript. You uploaded these files to a server (using a good'ol' FTP client), and the server simply handed these static assets to visitors. 

Life was simpler, and distinctions between roles were unnecessary.

## Server-side enters the bal room

Then PHP (and later ASP) arrived in my developer life and changed everything. Suddenly, web pages could respond dynamically to user input, pulling information from databases and altering content on-the-fly. We could also easily include one file in another, thus making a single file for a menu and including it in all our pages (without using SHTML!) 

For the first time, we began thinking about roles differently: people who designed and built user interfaces ("front-end") and those who handled databases and server-side logic ("back-end"). The distinction was clear, with one side more artsy and the other more techy.

## JavaScript frameworks changed the game

Frameworks like AngularJS, then React and Angular, Vue, and later Svelte came along and standardized how we built front-end applications. These frameworks made JavaScript development structured and disciplined. Front-end developers now had clear guidelines, best practices, and predictable workflows. Typescript arrived later to bring even more discipline. 

## Node.js blurred the boundaries

When came Node.js, which allowed JavaScript developers to handle server-side logic as well, the same language used for building front-end interfaces could run servers and handle back-end tasks. This began to seriously blur the lines between what we considered front-end and back-end development. 

Dependency management tools like NPM brought both sides even closer together. Front-end and back-end shared the same dependency management system. Build tools evolved alongside this shift, moving from Grunt and Gulp to Webpack, Rollup, Vite, and Bun. Developers now had a unified workflow, no matter which side of the stack they were working on.

## Cloud computing and CI/CD: no going back

Modern cloud platforms and CI/CD pipelines pushed this even further. Developers became responsible not only for writing code but also testing, deploying, and managing it. Infrastructure became programmable, thanks to Docker, Kubernetes and Terraform. Developers who once just coded UI components now also managed cloud infrastructure and deployments.

## APIs, microservices, and serverless!

API-driven architectures with REST and GraphQL meant teams could work seamlessly across the whole stack. Microservices and serverless platforms like AWS Lambda and Cloudflare Workers further removed the traditional roles by letting developers write and deploy functions without managing servers.

## The rise of the full-stack developer and DevOps

These changes gave birth to full-stack developers. No longer limited to a specific part of the stack, full-stack developers handle front-end interfaces, server-side logic, infrastructure, and deployments. Similarly, the "DevOps" role emerged, explicitly combining coding with operational tasks like infrastructure and deployment.

## It's time to ditch outdated labels

Today, labeling ourselves strictly as "front-end" or "back-end" developers feels outdated. Not only outdated, it has no grasp on the reality of development. The way we build software has evolved beyond these distinctions. Modern developers work fluidly across user interfaces, APIs, server logic, deployment automation, and cloud infrastructure. The boundaries we once drew between front-end and back-end simply don't match how we work anymore.

**Let's embrace what we really are: developers** building complete digital experiences. We don't need these old labels. We're creators who can build, ship, and scale entire products. Front-end or back-end doesn't matter. The only thing that matters is what we build. And that we build it well.

## What I look for in a developer today

As an Engineering Manager, these shifts have also changed what I value most when hiring developers. I'm less interested in rigid labels like "front-end" or "back-end" and more focused on **flexibility, curiosity, and willingness to adapt**. I look for developers who understand the full picture of an application, even if their strengths lean toward one area.

I value **collaboration and openness**. I look for people who can comfortably discuss and contribute across the stack. Developers who aren't afraid of infrastructure, who appreciate good UI, and who care deeply about user experience, performance, security, and scalability.

The ideal candidate isn't an expert in everything (nobody truly is), but they understand how pieces fit together. They're **ready to learn, quick to adapt, and eager to help** the team wherever needed. Technical skills can always be developed, but a genuine willingness to grow, adapt, and embrace the broader context of modern development is invaluable.

That's the kind of developer who thrives in today's evolving tech environment, and exactly the kind of person I want on my team.






